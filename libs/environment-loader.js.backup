/**
 * Load FBX environment model and add to scene
 * The protein will be positioned at the center of the environment
 */
var environmentModel = null; // Global reference to the environment model

function loadEnvironmentModel() {
    console.log('[ENV] loadEnvironmentModel function called');

    if (typeof THREE === 'undefined') {
        console.error('[ENV] THREE is not defined!');
        return;
    }

    console.log('[ENV] THREE.js version:', THREE.REVISION);

    if (typeof THREE.FBXLoader === 'undefined') {
        console.error('[ENV] FBXLoader not available');
        return;
    }

    if (typeof scene === 'undefined') {
        console.error('[ENV] Scene is not defined yet!');
        return;
    }

    console.log('[ENV] Creating FBXLoader instance...');
    const fbxLoader = new THREE.FBXLoader();

    // Add cache-busting parameter to ensure updated model is loaded
    const cacheBuster = '?t=' + new Date().getTime();
    const fbxUrl = 'env3.0.fbx' + cacheBuster;

    console.log('[ENV] Loading env3.0.fbx with cache buster...');
    fbxLoader.load(fbxUrl, function (object) {
        console.log('[ENV] FBX model loaded successfully!', object);

        // Store reference globally
        environmentModel = object;
        window.environmentModel = object;

        // Start with smaller scale since the model is too big
        object.scale.set(0.1, 0.1, 0.1);
        object.position.set(0, 0, 0);

        // Add the environment to the scene
        scene.add(object);

        console.log('[ENV] Environment model added to scene successfully');

        // Add enhanced lighting for better visual quality
        addEnhancedLighting();

        // List all meshes in the model for debugging
        listAllMeshes(object);

        // Apply shiny tiled texture to Cylinder.003 (or similar name)
        applyTextureToMesh(object, 'Cylinder.003');

        // Initialize controls after model is loaded
        initializeEnvironmentControls();
    }, function (xhr) {
        const percentComplete = (xhr.loaded / xhr.total * 100);
        console.log('[ENV] Loading progress: ' + percentComplete.toFixed(2) + '%');
    }, function (error) {
        const meshes = [];
        object.traverse(function (child) {
            if (child.isMesh) {
                meshes.push({
                    name: child.name,
                    type: child.type,
                    geometry: child.geometry ? child.geometry.type : 'none',
                    material: child.material ? child.material.type : 'none'
                });
                console.log('[ENV] - Mesh:', child.name, '| Type:', child.type, '| Material:', child.material ? child.material.type : 'none');
            }
        });
        console.log('[ENV] Total meshes found:', meshes.length);
        return meshes;
    }

function applyTextureToMesh(object, meshName) {
            console.log('[ENV] Applying procedural materials to all meshes...');

            let texturedMeshes = 0;

            // Traverse the object hierarchy
            object.traverse(function (child) {
                if (child.isMesh) {
                    const name = child.name;
                    console.log('[ENV] Processing mesh:', name);

                    // Apply different materials based on mesh name
                    if (name.includes('Cylinder')) {
                        // Different procedural textures for each cylinder
                        applyProceduralCylinderMaterial(child, name);
                        texturedMeshes++;
                    } else if (name === 'Plane') {
                        // Special floor/ground material for plane
                        applyProceduralPlaneMaterial(child);
                        texturedMeshes++;
                    }
                }
            });

            console.log('[ENV] Applied procedural materials to', texturedMeshes, 'mesh(es)');
        }

function applyProceduralCylinderMaterial(mesh, meshName) {
            // Create different materials based on cylinder name
            let material;

            if (meshName === 'Cylinder003') {
                // Shiny tiled floor pattern (original request)
                material = createTiledMaterial();
            } else if (meshName === 'Cylinder001') {
                // Metallic gold material
                material = createMetallicMaterial(0xFFD700, 0.9, 0.1);
            } else if (meshName === 'Cylinder004') {
                // Chrome/silver material
                material = createMetallicMaterial(0xC0C0C0, 1.0, 0.05);
            } else if (meshName === 'Cylinder005') {
                // Brushed metal with pattern
                material = createBrushedMetalMaterial();
            } else if (meshName === 'Cylinder006') {
                // Copper material
                material = createMetallicMaterial(0xB87333, 0.8, 0.2);
            } else {
                // Default: Carbon fiber pattern
                material = createCarbonFiberMaterial();
            }

            mesh.material = material;
            console.log('[ENV] Applied', material.name || 'procedural', 'material to', meshName);
        }

function createTiledMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Draw tiled pattern
            const tileSize = 64;
            for (let x = 0; x < canvas.width; x += tileSize) {
                for (let y = 0; y < canvas.height; y += tileSize) {
                    const isLight = ((x / tileSize) + (y / tileSize)) % 2 === 0;
                    ctx.fillStyle = isLight ? '#e0e0e0' : '#c0c0c0';
                    ctx.fillRect(x, y, tileSize, tileSize);

                    ctx.strokeStyle = '#a0a0a0';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x, y, tileSize, tileSize);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(4, 4);

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.7,
                roughness: 0.2,
                name: 'Tiled'
            });

            return material;
        }

function createMetallicMaterial(color, metalness, roughness) {
            return new THREE.MeshStandardMaterial({
                color: color,
                metalness: metalness,
                roughness: roughness,
                envMapIntensity: 1.5,
                name: 'Metallic'
            });
        }

function createBrushedMetalMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Base color
            ctx.fillStyle = '#888888';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Brushed lines
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            for (let i = 0; i < canvas.height; i += 2) {
                ctx.beginPath();
                ctx.moveTo(0, i);
                ctx.lineTo(canvas.width, i);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(2, 2);

            return new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.8,
                roughness: 0.3,
                name: 'Brushed Metal'
            });
        }

function createCarbonFiberMaterial() {
            const canvas = document.createElement('canvas');
            canvas.width = 512;
            canvas.height = 512;
            const ctx = canvas.getContext('2d');

            // Carbon fiber weave pattern
            ctx.fillStyle = '#1a1a1a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const weaveSize = 32;
            for (let x = 0; x < canvas.width; x += weaveSize) {
                for (let y = 0; y < canvas.height; y += weaveSize) {
                    // Horizontal weave
                    ctx.fillStyle = '#2a2a2a';
                    ctx.fillRect(x, y, weaveSize, weaveSize / 2);

                    // Vertical weave
                    ctx.fillStyle = '#252525';
                    ctx.fillRect(x, y + weaveSize / 2, weaveSize / 2, weaveSize / 2);
                }
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(8, 8);

            return new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.5,
                roughness: 0.4,
                name: 'Carbon Fiber'
            });
        }

function applyProceduralPlaneMaterial(mesh) {
            const canvas = document.createElement('canvas');
            canvas.width = 1024;
            canvas.height = 1024;
            const ctx = canvas.getContext('2d');

            // Concrete/stone floor texture
            ctx.fillStyle = '#4a4a4a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Add noise for concrete texture
            for (let i = 0; i < 5000; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                const size = Math.random() * 3;
                const brightness = Math.floor(Math.random() * 40) - 20;
                const color = 74 + brightness;
                ctx.fillStyle = `rgb(${color}, ${color}, ${color})`;
                ctx.fillRect(x, y, size, size);
            }

            // Add grid lines for floor tiles
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.3)';
            ctx.lineWidth = 2;
            const gridSize = 128;
            for (let x = 0; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.wrapT = THREE.RepeatWrapping;
            texture.repeat.set(10, 10);

            const material = new THREE.MeshStandardMaterial({
                map: texture,
                metalness: 0.1,
                roughness: 0.8,
                name: 'Concrete Floor'
            });

            mesh.material = material;
            mesh.receiveShadow = true; // Enable shadow receiving on floor

            console.log('[ENV] Applied concrete floor material to Plane');
        }

function initializeEnvironmentControls() {
            console.log('[ENV] Initializing environment controls...');

            // Get all slider elements
            const scaleX = document.getElementById('scaleX');
            const scaleY = document.getElementById('scaleY');
            const scaleZ = document.getElementById('scaleZ');
            const posX = document.getElementById('posX');
            const posY = document.getElementById('posY');
            const posZ = document.getElementById('posZ');

            // Set initial values to match the model
            if (scaleX) scaleX.value = 0.1;
            if (scaleY) scaleY.value = 0.1;
            if (scaleZ) scaleZ.value = 0.1;

            // Update display values
            updateSliderDisplays();

            // Add event listeners for scale sliders
            if (scaleX) scaleX.addEventListener('input', function () {
                if (environmentModel) {
                    environmentModel.scale.x = parseFloat(this.value);
                    document.getElementById('scaleXValue').textContent = parseFloat(this.value).toFixed(2);
                }
            });

            if (scaleY) scaleY.addEventListener('input', function () {
                if (environmentModel) {
                    environmentModel.scale.y = parseFloat(this.value);
                    document.getElementById('scaleYValue').textContent = parseFloat(this.value).toFixed(2);
                }
            });

            if (scaleZ) scaleZ.addEventListener('input', function () {
                if (environmentModel) {
                    environmentModel.scale.z = parseFloat(this.value);
                    document.getElementById('scaleZValue').textContent = parseFloat(this.value).toFixed(2);
                }
            });

            // Add event listeners for position sliders
            if (posX) posX.addEventListener('input', function () {
                if (environmentModel) {
                    environmentModel.position.x = parseFloat(this.value);
                    document.getElementById('posXValue').textContent = parseFloat(this.value).toFixed(2);
                }
            });

            if (posY) posY.addEventListener('input', function () {
                if (environmentModel) {
                    environmentModel.position.y = parseFloat(this.value);
                    document.getElementById('posYValue').textContent = parseFloat(this.value).toFixed(2);
                }
            });

            if (posZ) posZ.addEventListener('input', function () {
                if (environmentModel) {
                    environmentModel.position.z = parseFloat(this.value);
                    document.getElementById('posZValue').textContent = parseFloat(this.value).toFixed(2);
                }
            });

            // Reset button
            const resetBtn = document.getElementById('resetEnv');
            if (resetBtn) {
                resetBtn.addEventListener('click', function () {
                    if (environmentModel) {
                        environmentModel.scale.set(0.1, 0.1, 0.1);
                        environmentModel.position.set(0, 0, 0);

                        scaleX.value = 0.1;
                        scaleY.value = 0.1;
                        scaleZ.value = 0.1;
                        posX.value = 0;
                        posY.value = 0;
                        posZ.value = 0;

                        updateSliderDisplays();
                        console.log('[ENV] Reset to default values');
                    }
                });
            }

            // Toggle controls visibility
            const toggleBtn = document.getElementById('toggleEnvControls');
            const showBtn = document.getElementById('showEnvControls');
            const controlsPanel = document.getElementById('envControls');

            if (toggleBtn && controlsPanel && showBtn) {
                toggleBtn.addEventListener('click', function () {
                    controlsPanel.style.display = 'none';
                    showBtn.style.display = 'block';
                });

                showBtn.addEventListener('click', function () {
                    controlsPanel.style.display = 'block';
                    showBtn.style.display = 'none';
                });

                // Show controls panel by default when model loads
                controlsPanel.style.display = 'block';
                showBtn.style.display = 'none';
            }

            console.log('[ENV] Environment controls initialized');
        }

function updateSliderDisplays() {
            const scaleX = document.getElementById('scaleX');
            const scaleY = document.getElementById('scaleY');
            const scaleZ = document.getElementById('scaleZ');
            const posX = document.getElementById('posX');
            const posY = document.getElementById('posY');
            const posZ = document.getElementById('posZ');

            if (scaleX) document.getElementById('scaleXValue').textContent = parseFloat(scaleX.value).toFixed(2);
            if (scaleY) document.getElementById('scaleYValue').textContent = parseFloat(scaleY.value).toFixed(2);
            if (scaleZ) document.getElementById('scaleZValue').textContent = parseFloat(scaleZ.value).toFixed(2);
            if (posX) document.getElementById('posXValue').textContent = parseFloat(posX.value).toFixed(2);
            if (posY) document.getElementById('posYValue').textContent = parseFloat(posY.value).toFixed(2);
            if (posZ) document.getElementById('posZValue').textContent = parseFloat(posZ.value).toFixed(2);
        }

// Export the function to global scope
window.loadEnvironmentModel = loadEnvironmentModel;
    console.log('[ENV] loadEnvironmentModel function exposed to global scope');

    // Also export to PDB.render if available
    if (typeof PDB !== 'undefined' && PDB.render) {
        PDB.render.loadEnvironment = loadEnvironmentModel;
        console.log('[ENV] loadEnvironment function attached to PDB.render');
    }

    // Automatically call the function after a delay to ensure scene is initialized
    console.log('[ENV] Setting up automatic execution in 2 seconds...');
    setTimeout(function () {
        console.log('[ENV] Attempting to load environment model automatically...');
        loadEnvironmentModel();
    }, 2000);
